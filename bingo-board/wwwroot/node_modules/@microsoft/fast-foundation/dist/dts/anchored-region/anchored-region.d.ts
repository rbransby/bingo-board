import { FASTElement } from "@microsoft/fast-element";
import { ConstructibleResizeObserver } from "./resize-observer";
declare global {
    interface WindowWithResizeObserver extends Window {
        ResizeObserver: ConstructibleResizeObserver;
    }
}
export declare type AxisPositioningMode = "uncontrolled" | "locktodefault" | "dynamic";
export declare type AxisScalingMode = "anchor" | "fill" | "content";
export declare type GbcrUsage = "always" | "never" | "default";
export declare type HorizontalPosition = "start" | "end" | "left" | "right" | "unset";
export declare type VerticalPosition = "top" | "bottom" | "unset";
export interface Dimension {
    height: number;
    width: number;
}
/**
 * describes the possible horizontal positions of the region relative
 * to its anchor
 */
declare enum AnchoredRegionHorizontalPositionLabel {
    left = "left",
    insetLeft = "insetLeft",
    insetRight = "insetRight",
    right = "right",
    undefined = "undefined"
}
/**
 * describes the possible vertical positions of the region relative
 * to its anchor
 */
declare enum AnchoredRegionVerticalPositionLabel {
    top = "top",
    insetTop = "insetTop",
    insetBottom = "insetBottom",
    bottom = "bottom",
    undefined = "undefined"
}
export declare class AnchoredRegion extends FASTElement {
    private static DirectionAttributeName;
    /**
     * The HTML id of the anchor element this region is positioned relative to
     *
     * @public
     * @remarks
     * HTML Attribute: anchor
     */
    anchor: string;
    private anchorChanged;
    /**
     * The HTML id of the viewport element this region is positioned relative to
     *
     * @public
     * @remarks
     * HTML Attribute: anchor
     */
    viewport: string;
    private viewportChanged;
    /**
     * Sets what logic the component uses to determine horizontal placement.
     * 'locktodefault' forces the default position
     * 'dynamic' decides placement based on available space
     * 'uncontrolled' does not control placement on the horizontal axis
     *
     * @public
     * @remarks
     * HTML Attribute: horizontal-positioning-mode
     */
    horizontalPositioningMode: AxisPositioningMode;
    private horizontalPositioningModeChanged;
    /**
     * The default horizontal position of the region relative to the anchor element
     *
     * @public
     * @remarks
     * HTML Attribute: horizontal-default-position
     */
    horizontalDefaultPosition: HorizontalPosition;
    private horizontalDefaultPositionChanged;
    /**
     * Whether the region overlaps the anchor on the horizontal axis
     *
     * @public
     * @remarks
     * HTML Attribute: horizontal-inset
     */
    horizontalInset: boolean;
    private horizontalInsetChanged;
    /**
     * How narrow the space allocated to the default position has to be before the widest area
     * is selected for layout
     *
     * @public
     * @remarks
     * HTML Attribute: horizontal-threshold
     */
    horizontalThreshold: string;
    private horizontalThresholdChanged;
    /**
     * Defines how the width of the region is calculated
     *
     * @public
     * @remarks
     * HTML Attribute: horizontal-scaling
     */
    horizontalScaling: AxisScalingMode;
    private horizontalScalingChanged;
    /**
     * Sets what logic the component uses to determine vertical placement.
     * 'locktodefault' forces the default position
     * 'dynamic' decides placement based on available space
     * 'uncontrolled' does not control placement on the vertical axis
     *
     * @public
     * @remarks
     * HTML Attribute: vertical-positioning-mode
     */
    verticalPositioningMode: AxisPositioningMode;
    private verticalPositioningModeChanged;
    /**
     * The default vertical position of the region relative to the anchor element
     *
     * @public
     * @remarks
     * HTML Attribute: vertical-default-position
     */
    verticalDefaultPosition: VerticalPosition;
    private verticalDefaultPositionChanged;
    /**
     * Whether the region overlaps the anchor on the vertical axis
     *
     * @public
     * @remarks
     * HTML Attribute: vertical-inset
     */
    verticalInset: boolean;
    private verticalInsetChanged;
    /**
     * How short the space allocated to the default position has to be before the tallest area
     * is selected for layout
     *
     * @public
     * @remarks
     * HTML Attribute: vertical-threshold
     */
    verticalThreshold: string;
    private verticalThresholdChanged;
    /**
     * Defines how the height of the region is calculated
     *
     * @public
     * @remarks
     * HTML Attribute: vertical-scaling
     */
    verticalScaling: AxisScalingMode;
    private verticalScalingChanged;
    /**
     * Whether the region is positioned using css "position: fixed".
     * Otherwise the region uses "position: absolute".
     * Fixed placement allows the region to break out of parent containers,
     *
     * @public
     * @remarks
     * HTML Attribute: fixed-placement
     */
    fixedPlacement: boolean;
    private fixedPlacementChanged;
    /**
     * By default the component attempts to use intersection observer to calculate geometry and
     * falls back to getBoundingClientRect when that fails.  Setting this value to 'true' forces the
     * component to always use getBoundingClientRect calls.  Setting it to false prevents the component from
     * ever using getBoundingClientRect.  This is for performance tuning.
     *
     * @public
     * @remarks
     * HTML Attribute: use-gbcr
     */
    useGbcr: GbcrUsage;
    private useGbcrChanged;
    /**
     * The HTML element being used as the anchor
     *
     * @public
     */
    anchorElement: HTMLElement | null;
    private anchorElementChanged;
    /**
     * The HTML element being used as the viewport
     *
     * @public
     */
    viewportElement: HTMLElement | null;
    private viewportElementChanged;
    /**
     * indicates that an initial positioning pass on layout has completed
     *
     * @internal
     */
    initialLayoutComplete: boolean;
    /**
     * indicates the current horizontal position of the region
     */
    verticalPosition: AnchoredRegionVerticalPositionLabel;
    /**
     * indicates the current vertical position of the region
     */
    horizontalPosition: AnchoredRegionHorizontalPositionLabel;
    /**
     * values to be applied to the component's positioning attributes on render
     */
    private regionTop;
    private regionRight;
    private regionBottom;
    private regionLeft;
    /**
     * the span in pixels of the selected position on each axis
     */
    private regionWidth;
    private regionHeight;
    private xTransformOrigin;
    private yTransformOrigin;
    private intersectionDetector;
    private resizeDetector;
    private viewportRect;
    private regionDimension;
    private anchorTop;
    private anchorRight;
    private anchorBottom;
    private anchorLeft;
    private anchorHeight;
    private anchorWidth;
    /**
     * base offsets between the positioner's base position and the anchor's
     */
    private baseHorizontalOffset;
    private baseVerticalOffset;
    private pendingLayoutUpdate;
    private pendingReset;
    private currentDirection;
    private noIntersectionMode;
    /**
     * @internal
     */
    connectedCallback(): void;
    /**
     * @internal
     */
    disconnectedCallback(): void;
    /**
     * @internal
     */
    adoptedCallback(): void;
    /**
     * update position
     */
    update: () => void;
    /**
     * Public function to enable authors to update the layout based on changes in anchor offset without resorting
     * to a more epensive update call
     */
    updateAnchorOffset: (horizontalOffsetDelta: number, verticalOffsetDelta: number) => void;
    /**
     * destroys the instance's resize observer
     */
    private disconnectResizeDetector;
    /**
     * initializes the instance's resize observer
     */
    private initializeResizeDetector;
    /**
     * event thrown when the region's position changes
     */
    private updateLayoutForAttributeChange;
    /**
     * fully initializes the component
     */
    private initialize;
    /**
     * Request a layout update if there are currently no open requests
     */
    private requestLayoutUpdate;
    /**
     * Request a reset if there are currently no open requests
     */
    private requestReset;
    /**
     * sets the starting configuration for component internal values
     */
    private setInitialState;
    /**
     * initialize intersection detector
     */
    private initializeIntersectionDetector;
    /**
     * starts observers
     */
    private startObservers;
    /**
     * starts intersection observer
     */
    private startIntersectionObserver;
    /**
     * stops intersection observer
     */
    private stopIntersectionObserver;
    /**
     * stops observers
     */
    private stopObservers;
    /**
     * handle window resizes
     */
    private handleWindowResize;
    /**
     * disconnect intersection observer
     */
    private disconnectIntersectionDetector;
    /**
     * Gets the viewport element by id, or defaults to document root
     */
    private getViewport;
    /**
     *  Gets the anchor element by id
     */
    private getAnchor;
    /**
     *  Confirms that there is a valid relationship between the viewport and the intersection entry
     *  ie. that the data is useful
     */
    private isValidIntersection;
    /**
     *  Handle intersections
     */
    private handleIntersection;
    /**
     *  use getBoundingClientRect when intersection observer fails
     */
    private applyNoIntersectionMode;
    /**
     *  iterate through intersection entries and apply data
     */
    private applyIntersectionEntries;
    /**
     *  Update data based on anchor intersections
     */
    private handleAnchorIntersection;
    /**
     *  Update data based on positioner intersections
     */
    private handleRegionIntersection;
    /**
     *  Handle resize events
     */
    private handleResize;
    /**
     *  Handle region resize events
     */
    private handleRegionResize;
    /**
     * when there is not intersection observer this function is queued to update layout
     */
    private updateGeometry;
    /**
     * resets the component
     */
    private reset;
    /**
     *  Recalculate layout related state values
     */
    private updateLayout;
    /**
     *  Updates the style string applied to the region element as well as the css classes attached
     *  to the root element
     */
    private updateRegionStyle;
    /**
     * Get horizontal positioning state based on desired position
     */
    private setHorizontalPosition;
    /**
     * Get vertical positioning state based on desired position
     */
    private setVerticalPosition;
    /**
     *  Update the offset values
     */
    private updateRegionOffset;
    /**
     *  Get available Horizontal positions based on positioning mode
     */
    private getHorizontalPositioningOptions;
    /**
     * Get available Vertical positions based on positioning mode
     */
    private getVerticalPositioningOptions;
    /**
     *  Get the width available for a particular horizontal position
     */
    private getAvailableWidth;
    /**
     *  Get the height available for a particular vertical position
     */
    private getAvailableHeight;
    /**
     * Get region dimensions
     */
    private getNextRegionDimension;
    /**
     *  gets the current direction
     */
    private getDirection;
}
export {};
