import { __decorate } from "tslib";
import { attr, FASTElement, observable } from "@microsoft/fast-element";
import { Direction, keyCodeArrowDown, keyCodeArrowLeft, keyCodeArrowRight, keyCodeArrowUp, keyCodeEnter, keyCodeSpace, keyCodeTab, Orientation, } from "@microsoft/fast-web-utilities";
import { getDirection } from "../utilities";
/**
 * An Radio Group Custom HTML Element.
 * Implements the {@link https://www.w3.org/TR/wai-aria-1.1/#radiogroup | ARIA radiogroup }.
 *
 * @public
 */
export class RadioGroup extends FASTElement {
    constructor() {
        super();
        /**
         * The orientation of the group
         *
         * @public
         * @remarks
         * HTML Attribute: orientation
         */
        this.orientation = Orientation.horizontal;
        this.isInsideToolbar = false;
        this.keypressHandler = (e) => {
            const radio = e.target;
            if (radio) {
                radio.setAttribute("tabindex", radio.checked ? "0" : "-1");
            }
        };
        this.radioChangeHandler = (e) => {
            const changedRadio = e.target;
            if (changedRadio.checked) {
                this.slottedRadioButtons.forEach((radio) => {
                    if (radio !== changedRadio) {
                        radio.checked = false;
                        radio.setAttribute("tabindex", "-1");
                    }
                });
                this.selectedRadio = changedRadio;
                this.value = changedRadio.value;
            }
        };
        this.moveToRadioByIndex = (group, index) => {
            const radio = group[index];
            if (!this.isInsideToolbar) {
                radio.setAttribute("tabindex", "0");
                if (radio.readOnly) {
                    this.slottedRadioButtons.forEach((nextRadio) => {
                        if (nextRadio !== radio) {
                            nextRadio.setAttribute("tabindex", "-1");
                        }
                    });
                }
                else {
                    radio.checked = true;
                    this.selectedRadio = radio;
                }
            }
            this.focusedRadio = radio;
            radio.focus();
        };
        this.moveRightOffGroup = () => {
            this.nextElementSibling.focus();
        };
        this.moveLeftOffGroup = () => {
            this.previousElementSibling.focus();
        };
        /* eslint-disable-next-line @typescript-eslint/no-unused-vars */
        this.focusOutHandler = (e) => {
            const group = this.slottedRadioButtons;
            const radio = e.target;
            const index = radio !== null ? group.indexOf(radio) : 0;
            const focusedIndex = this.focusedRadio
                ? group.indexOf(this.focusedRadio)
                : -1;
            if ((focusedIndex === 0 && index === focusedIndex) ||
                (focusedIndex === group.length - 1 && focusedIndex === index)) {
                if (!this.selectedRadio) {
                    this.focusedRadio = group[0];
                    this.focusedRadio.setAttribute("tabindex", "0");
                    group.forEach((nextRadio) => {
                        if (nextRadio !== this.focusedRadio) {
                            nextRadio.setAttribute("tabindex", "-1");
                        }
                    });
                }
                else {
                    this.selectedRadio.setAttribute("tabindex", "0");
                    this.focusedRadio = this.selectedRadio;
                    group.forEach((nextRadio) => {
                        if (nextRadio !== this.selectedRadio) {
                            nextRadio.setAttribute("tabindex", "-1");
                        }
                    });
                }
            }
        };
        this.clickHandler = (e) => {
            const radio = e.target;
            if (radio) {
                const group = this.slottedRadioButtons;
                if (radio.checked || group.indexOf(radio) === 0) {
                    radio.setAttribute("tabindex", "0");
                    this.selectedRadio = radio;
                }
                else {
                    radio.setAttribute("tabindex", "-1");
                    this.selectedRadio = null;
                }
                this.focusedRadio = radio;
            }
            e.preventDefault();
        };
        this.shouldMoveOffGroupToTheRight = (index, group, keyCode) => {
            return (index === group.length &&
                this.isInsideToolbar &&
                keyCode === keyCodeArrowRight);
        };
        this.shouldMoveOffGroupToTheLeft = (group, keyCode) => {
            const index = this.focusedRadio ? group.indexOf(this.focusedRadio) - 1 : 0;
            return index < 0 && this.isInsideToolbar && keyCode === keyCodeArrowLeft;
        };
        this.checkFocusedRadio = () => {
            if (this.focusedRadio !== null &&
                !this.focusedRadio.readOnly &&
                !this.focusedRadio.checked) {
                this.focusedRadio.checked = true;
                this.focusedRadio.setAttribute("tabindex", "0");
                this.focusedRadio.focus();
                this.selectedRadio = this.focusedRadio;
            }
        };
        this.moveRight = (e) => {
            const group = this.slottedRadioButtons;
            let index = 0;
            index = this.focusedRadio ? group.indexOf(this.focusedRadio) + 1 : 1;
            if (this.shouldMoveOffGroupToTheRight(index, group, e.keyCode)) {
                this.moveRightOffGroup();
                return;
            }
            else if (index === group.length) {
                index = 0;
            }
            /* looping to get to next radio that is not disabled */
            /* matching native radio/radiogroup which does not select an item if there is only 1 in the group */
            while (index < group.length && group.length > 1) {
                if (!group[index].disabled) {
                    this.moveToRadioByIndex(group, index);
                    break;
                }
                else if (this.focusedRadio && index === group.indexOf(this.focusedRadio)) {
                    break;
                }
                else if (index + 1 >= group.length) {
                    if (this.isInsideToolbar) {
                        break;
                    }
                    else {
                        index = 0;
                    }
                }
                else {
                    index += 1;
                }
            }
        };
        this.moveLeft = (e) => {
            const group = this.slottedRadioButtons;
            let index = 0;
            index = this.focusedRadio ? group.indexOf(this.focusedRadio) - 1 : 0;
            index = index < 0 ? group.length - 1 : index;
            if (this.shouldMoveOffGroupToTheLeft(group, e.keyCode)) {
                this.moveLeftOffGroup();
                return;
            }
            /* looping to get to next radio that is not disabled */
            while (index >= 0 && group.length > 1) {
                if (!group[index].disabled) {
                    this.moveToRadioByIndex(group, index);
                    break;
                }
                else if (this.focusedRadio && index === group.indexOf(this.focusedRadio)) {
                    break;
                }
                else if (index - 1 < 0) {
                    index = group.length - 1;
                }
                else {
                    index -= 1;
                }
            }
        };
        /**
         * keyboard handling per https://w3c.github.io/aria-practices/#for-radio-groups-not-contained-in-a-toolbar
         * navigation is different when there is an ancestor with role='toolbar'
         *
         * @internal
         */
        this.keydownHandler = (e) => {
            if (e.keyCode !== keyCodeTab && e.keyCode !== keyCodeSpace) {
                e.preventDefault();
            }
            switch (e.keyCode) {
                case keyCodeEnter:
                    this.checkFocusedRadio();
                    break;
                case keyCodeArrowRight:
                case keyCodeArrowDown:
                    if (this.direction === Direction.ltr) {
                        this.moveRight(e);
                    }
                    else {
                        this.moveLeft(e);
                    }
                    break;
                case keyCodeArrowLeft:
                case keyCodeArrowUp:
                    if (this.direction === Direction.ltr) {
                        this.moveLeft(e);
                    }
                    else {
                        this.moveRight(e);
                    }
                    break;
            }
        };
        this.addEventListener("keydown", this.keydownHandler);
        this.addEventListener("change", this.radioChangeHandler);
        this.addEventListener("keypress", this.keypressHandler);
        this.addEventListener("click", this.clickHandler);
        this.addEventListener("focusout", this.focusOutHandler);
    }
    readOnlyChanged() {
        if (this.slottedRadioButtons !== undefined) {
            this.slottedRadioButtons.forEach((radio) => {
                if (this.readOnly) {
                    radio.readOnly = true;
                }
                else {
                    radio.readOnly = false;
                }
            });
        }
    }
    disabledChanged() {
        if (this.slottedRadioButtons !== undefined) {
            this.slottedRadioButtons.forEach((radio) => {
                if (this.disabled) {
                    radio.disabled = true;
                }
                else {
                    radio.disabled = false;
                }
            });
        }
    }
    nameChanged() {
        if (this.slottedRadioButtons) {
            this.slottedRadioButtons.forEach((radio) => {
                radio.setAttribute("name", this.name);
            });
        }
    }
    slottedRadioButtonsChanged(oldValue, newValue) {
        if (this.slottedRadioButtons && this.slottedRadioButtons.length > 0) {
            this.setupRadioButtons();
        }
    }
    /**
     * @internal
     */
    connectedCallback() {
        var _a;
        super.connectedCallback();
        this.direction = getDirection(this);
        this.setupRadioButtons();
        this.parentToolbar = (_a = this.parentElement) === null || _a === void 0 ? void 0 : _a.closest('[role="toolbar"]');
        this.isInsideToolbar =
            this.parentToolbar !== undefined && this.parentToolbar !== null;
    }
    setupRadioButtons() {
        this.slottedRadioButtons.forEach((radio) => {
            if (this.name !== undefined) {
                radio.setAttribute("name", this.name);
            }
            if (this.disabled) {
                radio.disabled = true;
            }
            if (this.readOnly) {
                radio.readOnly = true;
            }
            if (this.value && this.value === radio.getAttribute("value")) {
                this.selectedRadio = radio;
                this.focusedRadio = radio;
                radio.checked = true;
                radio.setAttribute("tabindex", "0");
            }
            else {
                radio.setAttribute("tabindex", "-1");
            }
        });
        if (this.value === undefined && this.slottedRadioButtons.length > 0) {
            this.slottedRadioButtons[0].setAttribute("tabindex", "0");
            this.focusedRadio = this.slottedRadioButtons[0];
        }
    }
}
__decorate([
    attr({ attribute: "readonly", mode: "boolean" })
], RadioGroup.prototype, "readOnly", void 0);
__decorate([
    attr({ attribute: "disabled", mode: "boolean" })
], RadioGroup.prototype, "disabled", void 0);
__decorate([
    attr
], RadioGroup.prototype, "name", void 0);
__decorate([
    attr
], RadioGroup.prototype, "value", void 0);
__decorate([
    attr
], RadioGroup.prototype, "orientation", void 0);
__decorate([
    observable
], RadioGroup.prototype, "childItems", void 0);
__decorate([
    observable
], RadioGroup.prototype, "slottedRadioButtons", void 0);
