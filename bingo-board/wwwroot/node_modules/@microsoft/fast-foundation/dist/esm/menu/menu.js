import { __decorate } from "tslib";
import { FASTElement, observable } from "@microsoft/fast-element";
import { inRange, invert } from "lodash-es";
import { isHTMLElement, keyCodeArrowDown, keyCodeArrowLeft, keyCodeArrowRight, keyCodeArrowUp, keyCodeEnd, keyCodeHome, } from "@microsoft/fast-web-utilities";
import { MenuItemRole } from "../menu-item/index";
/**
 * A Menu Custom HTML Element.
 * Implements the {@link https://www.w3.org/TR/wai-aria-1.1/#menu | ARIA menu }.
 *
 * @public
 */
export class Menu extends FASTElement {
    constructor() {
        super(...arguments);
        /**
         * The index of the focusable element in the items array
         * defaults to -1
         */
        this.focusIndex = -1;
        /**
         * if focus is moving out of the menu, reset to a stable initial state
         * @internal
         */
        this.handleFocusOut = (e) => {
            const isNestedEl = this.contains(e.relatedTarget);
            if (!isNestedEl) {
                // find our first focusable element
                const focusIndex = this.menuItems.findIndex(this.isFocusableElement);
                // set the current focus index's tabindex to -1
                this.menuItems[this.focusIndex].setAttribute("tabindex", "");
                // set the first focusable element tabindex to 0
                this.menuItems[focusIndex].setAttribute("tabindex", "0");
                // set the focus index
                this.focusIndex = focusIndex;
            }
        };
        this.setItems = () => {
            const focusIndex = this.menuItems.findIndex(this.isFocusableElement);
            // if our focus index is not -1 we have items
            if (focusIndex !== -1) {
                this.focusIndex = focusIndex;
            }
            for (let item = 0; item < this.menuItems.length; item++) {
                if (item === focusIndex) {
                    this.menuItems[item].setAttribute("tabindex", "0");
                }
                this.menuItems[item].addEventListener("blur", this.handleMenuItemFocus);
            }
        };
        this.resetItems = (oldValue) => {
            for (let item = 0; item < oldValue.length; item++) {
                oldValue[item].removeEventListener("blur", this.handleMenuItemFocus);
            }
        };
        /**
         * check if the item is a menu item
         */
        this.isMenuItemElement = (el) => {
            return (isHTMLElement(el) &&
                Menu.focusableElementRoles.hasOwnProperty(el.getAttribute("role")));
        };
        /**
         * check if the item is disabled
         */
        this.isDisabledElement = (el) => {
            return this.isMenuItemElement(el) && el.getAttribute("aria-disabled") === "true";
        };
        /**
         * check if the item is focusable
         */
        this.isFocusableElement = (el) => {
            return this.isMenuItemElement(el) && !this.isDisabledElement(el);
        };
        this.handleMenuItemFocus = (e) => {
            const target = e.currentTarget;
            const focusIndex = this.menuItems.indexOf(target);
            if (this.isDisabledElement(target)) {
                target.blur();
                return;
            }
            if (focusIndex !== this.focusIndex && focusIndex !== -1) {
                this.setFocus(focusIndex, focusIndex > this.focusIndex ? 1 : -1);
            }
        };
    }
    itemsChanged(oldValue, newValue) {
        if (this.$fastController.isConnected) {
            this.menuItems = this.domChildren();
            this.resetItems(oldValue);
            this.setItems();
        }
    }
    /**
     * @internal
     */
    connectedCallback() {
        super.connectedCallback();
        this.menuItems = this.domChildren();
    }
    /**
     * @internal
     */
    disconnectedCallback() {
        super.disconnectedCallback();
        this.menuItems = [];
    }
    /**
     * Focuses the first item in the menu.
     *
     * @public
     */
    focus() {
        this.setFocus(0, 1);
    }
    /**
     * @internal
     */
    handleMenuKeyDown(e) {
        if (e.defaultPrevented) {
            return;
        }
        switch (e.keyCode) {
            case keyCodeArrowDown:
            case keyCodeArrowRight:
                // go forward one index
                this.setFocus(this.focusIndex + 1, 1);
                return;
            case keyCodeArrowUp:
            case keyCodeArrowLeft:
                // go back one index
                this.setFocus(this.focusIndex - 1, -1);
                return;
            case keyCodeEnd:
                // set focus on last item
                this.setFocus(this.domChildren().length - 1, -1);
                return;
            case keyCodeHome:
                // set focus on first item
                this.setFocus(0, 1);
                return;
            default:
                // if we are not handling the event, do not prevent default
                return true;
        }
    }
    /**
     * get an array of valid DOM children
     */
    domChildren() {
        return Array.from(this.children);
    }
    setFocus(focusIndex, adjustment) {
        const children = this.menuItems;
        while (inRange(focusIndex, children.length)) {
            const child = children[focusIndex];
            if (this.isFocusableElement(child)) {
                // update the tabindex of next focusable element
                child.setAttribute("tabindex", "0");
                // focus the element
                child.focus();
                // change the previous index to -1
                children[this.focusIndex].setAttribute("tabindex", "");
                // update the focus index
                this.focusIndex = focusIndex;
                break;
            }
            focusIndex += adjustment;
        }
    }
}
Menu.focusableElementRoles = invert(MenuItemRole);
__decorate([
    observable
], Menu.prototype, "items", void 0);
