import { __decorate } from "tslib";
import { attr, nullableNumberConverter, observable } from "@microsoft/fast-element";
import { FormAssociated } from "../form-associated/form-associated";
import { DelegatesARIATextbox } from "../text-field/index";
import { applyMixins } from "../utilities";
/**
 * Resize mode for a TextArea
 * @public
 */
export var TextAreaResize;
(function (TextAreaResize) {
    /**
     * No resize.
     */
    TextAreaResize["none"] = "none";
    /**
     * Resize vertically and horizontally.
     */
    TextAreaResize["both"] = "both";
    /**
     * Resize horizontally.
     */
    TextAreaResize["horizontal"] = "horizontal";
    /**
     * Resize vertically.
     */
    TextAreaResize["vertical"] = "vertical";
})(TextAreaResize || (TextAreaResize = {}));
/**
 * An Text Area Custom HTML Element.
 * Based largely on the {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/textarea | <textarea> element }.
 *
 * @public
 */
export class TextArea extends FormAssociated {
    constructor() {
        super(...arguments);
        /**
         * The resize mode of the element.
         * @public
         * @remarks
         * HTML Attribute: resize
         */
        this.resize = TextAreaResize.none;
        /**
         * Sizes the element horizontally by a number of character columns.
         *
         * @public
         * @remarks
         * HTML Attribute: cols
         */
        this.cols = 20;
        this.proxy = document.createElement("textarea");
        /**
         * @internal
         */
        this.handleTextInput = () => {
            this.value = this.control.value;
        };
    }
    readOnlyChanged() {
        if (this.proxy instanceof HTMLElement) {
            this.proxy.readOnly = this.readOnly;
        }
    }
    autofocusChanged() {
        if (this.proxy instanceof HTMLElement) {
            this.proxy.autofocus = this.autofocus;
        }
    }
    listChanged() {
        if (this.proxy instanceof HTMLElement) {
            this.proxy.setAttribute("list", this.list);
        }
    }
    maxlengthChanged() {
        if (this.proxy instanceof HTMLElement) {
            this.proxy.maxLength = this.maxlength;
        }
    }
    minlengthChanged() {
        if (this.proxy instanceof HTMLElement) {
            this.proxy.minLength = this.minlength;
        }
    }
    spellcheckChanged() {
        if (this.proxy instanceof HTMLElement) {
            this.proxy.spellcheck = this.spellcheck;
        }
    }
    /**
     * Change event handler for inner control.
     * @remarks
     * "Change" events are not `composable` so they will not
     * permeate the shadow DOM boundary. This fn effectively proxies
     * the change event, emitting a `change` event whenever the internal
     * control emits a `change` event
     * @internal
     */
    handleChange() {
        this.$emit("change");
    }
}
__decorate([
    attr({ mode: "boolean" })
], TextArea.prototype, "readOnly", void 0);
__decorate([
    attr
], TextArea.prototype, "resize", void 0);
__decorate([
    attr({ mode: "boolean" })
], TextArea.prototype, "autofocus", void 0);
__decorate([
    attr({ attribute: "form" })
], TextArea.prototype, "formId", void 0);
__decorate([
    attr
], TextArea.prototype, "list", void 0);
__decorate([
    attr({ converter: nullableNumberConverter })
], TextArea.prototype, "maxlength", void 0);
__decorate([
    attr({ converter: nullableNumberConverter })
], TextArea.prototype, "minlength", void 0);
__decorate([
    attr
], TextArea.prototype, "name", void 0);
__decorate([
    attr
], TextArea.prototype, "placeholder", void 0);
__decorate([
    attr({ converter: nullableNumberConverter, mode: "fromView" })
], TextArea.prototype, "cols", void 0);
__decorate([
    attr({ converter: nullableNumberConverter, mode: "fromView" })
], TextArea.prototype, "rows", void 0);
__decorate([
    attr({ mode: "boolean" })
], TextArea.prototype, "spellcheck", void 0);
__decorate([
    observable
], TextArea.prototype, "defaultSlottedNodes", void 0);
applyMixins(TextArea, DelegatesARIATextbox);
