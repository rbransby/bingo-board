import { __decorate } from "tslib";
import { attr, FASTElement, observable, Observable, } from "@microsoft/fast-element";
import { getDisplayedNodes, isHTMLElement, keyCodeArrowDown, keyCodeArrowLeft, keyCodeArrowRight, keyCodeArrowUp, keyCodeEnter, keyCodeSpace, } from "@microsoft/fast-web-utilities";
import { StartEnd } from "../patterns/start-end";
import { applyMixins } from "../utilities/apply-mixins";
/**
 * check if the item is a tree item
 * @public
 * @remarks
 * determines if element is an HTMLElement and if it has the role treeitem
 */
export function isTreeItemElement(el) {
    return isHTMLElement(el) && el.getAttribute("role") === "treeitem";
}
/**
 * A Tree item Custom HTML Element.
 *
 * @public
 */
export class TreeItem extends FASTElement {
    constructor() {
        super(...arguments);
        /**
         * When true, the control will be appear expanded by user interaction.
         * @public
         * @remarks
         * HTML Attribute: expanded
         */
        this.expanded = false;
        this.focusable = false;
        this.handleFocus = (e) => {
            if (e.target === e.currentTarget) {
                this.focusable = true;
            }
        };
        this.handleBlur = (e) => {
            if (e.target !== e.currentTarget) {
                return;
            }
            this.focusable = false;
        };
        this.handleKeyDown = (e) => {
            if (e.target !== e.currentTarget) {
                return true;
            }
            switch (e.keyCode) {
                case keyCodeArrowLeft:
                    this.handleArrowLeft();
                    break;
                case keyCodeArrowRight:
                    this.handleArrowRight();
                    break;
                case keyCodeArrowDown:
                    // preventDefault to ensure we don't scroll the page
                    e.preventDefault();
                    this.focusNextNode(1);
                    break;
                case keyCodeArrowUp:
                    // preventDefault to ensure we don't scroll the page
                    e.preventDefault();
                    this.focusNextNode(-1);
                    break;
                case keyCodeEnter:
                    this.handleSelected(e);
                    break;
                case keyCodeSpace:
                    this.handleSpaceBar();
                    break;
            }
            return true;
        };
        this.handleExpandCollapseButtonClick = () => {
            if (!this.disabled) {
                this.setExpanded(!this.expanded);
            }
        };
        this.handleContainerClick = (e) => {
            const expandButton = this.expandCollapseButton;
            const isButtonAnHTMLElement = isHTMLElement(expandButton);
            if ((!isButtonAnHTMLElement ||
                (isButtonAnHTMLElement && expandButton !== e.target)) &&
                !this.disabled) {
                this.handleSelected(e);
            }
        };
        this.isNestedItem = () => {
            return isTreeItemElement(this.parentElement);
        };
    }
    itemsChanged(oldValue, newValue) {
        if (this.$fastController.isConnected) {
            this.items.forEach((node) => {
                if (isTreeItemElement(node)) {
                    // TODO: maybe not require it to be a TreeItem?
                    node.nested = true;
                }
            });
        }
    }
    getParentTreeNode() {
        const parentNode = this.parentElement.closest("[role='tree']");
        return parentNode;
    }
    /**
     * @internal
     */
    connectedCallback() {
        super.connectedCallback();
        const parentTreeNode = this.getParentTreeNode();
        if (parentTreeNode) {
            if (parentTreeNode.hasAttribute("render-collapsed-nodes")) {
                this.renderCollapsedChildren =
                    parentTreeNode.getAttribute("render-collapsed-nodes") === "true";
            }
            this.notifier = Observable.getNotifier(parentTreeNode);
            this.notifier.subscribe(this, "renderCollapsedNodes");
        }
    }
    /**
     * @internal
     */
    disconnectedCallback() {
        super.disconnectedCallback();
        if (this.notifier) {
            this.notifier.unsubscribe(this, "renderCollapsedNodes");
        }
    }
    handleChange(source, propertyName) {
        switch (propertyName) {
            case "renderCollapsedNodes":
                this.renderCollapsedChildren = source.renderCollapsedNodes;
                break;
        }
    }
    childItemLength() {
        const treeChildren = this.childItems.filter((item) => {
            return isTreeItemElement(item);
        });
        return treeChildren ? treeChildren.length : 0;
    }
    handleArrowLeft() {
        if (this.expanded) {
            this.setExpanded(false);
        }
        else if (isHTMLElement(this.parentElement)) {
            const parentTreeItemNode = this.parentElement.closest("[role='treeitem']");
            if (isHTMLElement(parentTreeItemNode)) {
                parentTreeItemNode.focus();
            }
        }
    }
    handleArrowRight() {
        if (typeof this.expanded !== "boolean") {
            return;
        }
        if (!this.expanded) {
            this.setExpanded(true);
        }
        else {
            this.focusNextNode(1);
        }
    }
    handleSpaceBar() {
        if (typeof this.expanded !== "boolean") {
            return;
        }
        this.setExpanded(!this.expanded);
    }
    focusNextNode(delta) {
        const visibleNodes = this.getVisibleNodes();
        if (!visibleNodes) {
            return;
        }
        const currentIndex = visibleNodes.indexOf(this);
        if (currentIndex !== -1) {
            let nextElement = visibleNodes[currentIndex + delta];
            if (nextElement !== undefined) {
                while (nextElement.hasAttribute("disabled")) {
                    const offset = delta >= 0 ? 1 : -1;
                    nextElement = visibleNodes[currentIndex + delta + offset];
                    if (!nextElement) {
                        break;
                    }
                }
            }
            if (isHTMLElement(nextElement)) {
                nextElement.focus();
            }
        }
    }
    getVisibleNodes() {
        return getDisplayedNodes(this.getTreeRoot(), "[role='treeitem']");
    }
    getTreeRoot() {
        /* eslint-disable-next-line  @typescript-eslint/no-this-alias */
        const currentNode = this;
        if (!isHTMLElement(currentNode)) {
            return null;
        }
        return currentNode.closest("[role='tree']");
    }
    handleSelected(e) {
        this.selected = !this.selected;
        this.$emit("selected-change", e);
    }
    setExpanded(expanded) {
        this.expanded = expanded;
        this.$emit("expanded-change", this);
    }
}
__decorate([
    attr({ mode: "boolean" })
], TreeItem.prototype, "expanded", void 0);
__decorate([
    attr({ mode: "boolean" })
], TreeItem.prototype, "selected", void 0);
__decorate([
    attr({ mode: "boolean" })
], TreeItem.prototype, "disabled", void 0);
__decorate([
    observable
], TreeItem.prototype, "focusable", void 0);
__decorate([
    observable
], TreeItem.prototype, "childItems", void 0);
__decorate([
    observable
], TreeItem.prototype, "items", void 0);
__decorate([
    observable
], TreeItem.prototype, "nested", void 0);
__decorate([
    observable
], TreeItem.prototype, "renderCollapsedChildren", void 0);
applyMixins(TreeItem, StartEnd);
