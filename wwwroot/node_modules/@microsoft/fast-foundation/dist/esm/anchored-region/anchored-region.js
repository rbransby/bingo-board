import { __decorate } from "tslib";
import { attr, DOM, FASTElement, observable } from "@microsoft/fast-element";
import { Direction } from "@microsoft/fast-web-utilities";
/**
 * describes the possible horizontal positions of the region relative
 * to its anchor
 */
var AnchoredRegionHorizontalPositionLabel;
(function (AnchoredRegionHorizontalPositionLabel) {
    AnchoredRegionHorizontalPositionLabel["left"] = "left";
    AnchoredRegionHorizontalPositionLabel["insetLeft"] = "insetLeft";
    AnchoredRegionHorizontalPositionLabel["insetRight"] = "insetRight";
    AnchoredRegionHorizontalPositionLabel["right"] = "right";
    AnchoredRegionHorizontalPositionLabel["undefined"] = "undefined";
})(AnchoredRegionHorizontalPositionLabel || (AnchoredRegionHorizontalPositionLabel = {}));
/**
 * describes the possible vertical positions of the region relative
 * to its anchor
 */
var AnchoredRegionVerticalPositionLabel;
(function (AnchoredRegionVerticalPositionLabel) {
    AnchoredRegionVerticalPositionLabel["top"] = "top";
    AnchoredRegionVerticalPositionLabel["insetTop"] = "insetTop";
    AnchoredRegionVerticalPositionLabel["insetBottom"] = "insetBottom";
    AnchoredRegionVerticalPositionLabel["bottom"] = "bottom";
    AnchoredRegionVerticalPositionLabel["undefined"] = "undefined";
})(AnchoredRegionVerticalPositionLabel || (AnchoredRegionVerticalPositionLabel = {}));
/**
 * location enum for transform origin settings
 */
var Location;
(function (Location) {
    Location["top"] = "top";
    Location["left"] = "left";
    Location["right"] = "right";
    Location["bottom"] = "bottom";
})(Location || (Location = {}));
export class AnchoredRegion extends FASTElement {
    constructor() {
        super(...arguments);
        /**
         * The HTML id of the anchor element this region is positioned relative to
         *
         * @public
         * @remarks
         * HTML Attribute: anchor
         */
        this.anchor = "";
        /**
         * The HTML id of the viewport element this region is positioned relative to
         *
         * @public
         * @remarks
         * HTML Attribute: anchor
         */
        this.viewport = "";
        /**
         * Sets what logic the component uses to determine horizontal placement.
         * 'locktodefault' forces the default position
         * 'dynamic' decides placement based on available space
         * 'uncontrolled' does not control placement on the horizontal axis
         *
         * @public
         * @remarks
         * HTML Attribute: horizontal-positioning-mode
         */
        this.horizontalPositioningMode = "uncontrolled";
        /**
         * The default horizontal position of the region relative to the anchor element
         *
         * @public
         * @remarks
         * HTML Attribute: horizontal-default-position
         */
        this.horizontalDefaultPosition = "unset";
        /**
         * Whether the region overlaps the anchor on the horizontal axis
         *
         * @public
         * @remarks
         * HTML Attribute: horizontal-inset
         */
        this.horizontalInset = false;
        /**
         * How narrow the space allocated to the default position has to be before the widest area
         * is selected for layout
         *
         * @public
         * @remarks
         * HTML Attribute: horizontal-threshold
         */
        this.horizontalThreshold = "";
        /**
         * Defines how the width of the region is calculated
         *
         * @public
         * @remarks
         * HTML Attribute: horizontal-scaling
         */
        this.horizontalScaling = "content";
        /**
         * Sets what logic the component uses to determine vertical placement.
         * 'locktodefault' forces the default position
         * 'dynamic' decides placement based on available space
         * 'uncontrolled' does not control placement on the vertical axis
         *
         * @public
         * @remarks
         * HTML Attribute: vertical-positioning-mode
         */
        this.verticalPositioningMode = "uncontrolled";
        /**
         * The default vertical position of the region relative to the anchor element
         *
         * @public
         * @remarks
         * HTML Attribute: vertical-default-position
         */
        this.verticalDefaultPosition = "unset";
        /**
         * Whether the region overlaps the anchor on the vertical axis
         *
         * @public
         * @remarks
         * HTML Attribute: vertical-inset
         */
        this.verticalInset = false;
        /**
         * How short the space allocated to the default position has to be before the tallest area
         * is selected for layout
         *
         * @public
         * @remarks
         * HTML Attribute: vertical-threshold
         */
        this.verticalThreshold = "";
        /**
         * Defines how the height of the region is calculated
         *
         * @public
         * @remarks
         * HTML Attribute: vertical-scaling
         */
        this.verticalScaling = "content";
        /**
         * Whether the region is positioned using css "position: fixed".
         * Otherwise the region uses "position: absolute".
         * Fixed placement allows the region to break out of parent containers,
         *
         * @public
         * @remarks
         * HTML Attribute: fixed-placement
         */
        this.fixedPlacement = false;
        /**
         * By default the component attempts to use intersection observer to calculate geometry and
         * falls back to getBoundingClientRect when that fails.  Setting this value to 'true' forces the
         * component to always use getBoundingClientRect calls.  Setting it to false prevents the component from
         * ever using getBoundingClientRect.  This is for performance tuning.
         *
         * @public
         * @remarks
         * HTML Attribute: use-gbcr
         */
        this.useGbcr = "default";
        /**
         * The HTML element being used as the anchor
         *
         * @public
         */
        this.anchorElement = null;
        /**
         * The HTML element being used as the viewport
         *
         * @public
         */
        this.viewportElement = null;
        /**
         * indicates that an initial positioning pass on layout has completed
         *
         * @internal
         */
        this.initialLayoutComplete = false;
        this.intersectionDetector = null;
        this.resizeDetector = null;
        this.pendingLayoutUpdate = false;
        this.pendingReset = false;
        this.currentDirection = Direction.ltr;
        this.noIntersectionMode = false;
        /**
         * update position
         */
        this.update = () => {
            if (this.useGbcr === "always" || this.noIntersectionMode) {
                this.updateGeometry();
                return;
            }
            if (this.viewportRect === null || this.regionDimension === null) {
                this.requestLayoutUpdate();
                return;
            }
            this.stopIntersectionObserver();
            this.startIntersectionObserver();
        };
        /**
         * Public function to enable authors to update the layout based on changes in anchor offset without resorting
         * to a more epensive update call
         */
        this.updateAnchorOffset = (horizontalOffsetDelta, verticalOffsetDelta) => {
            this.anchorLeft = this.anchorLeft + horizontalOffsetDelta;
            this.anchorRight = this.anchorRight + horizontalOffsetDelta;
            this.anchorTop = this.anchorTop + verticalOffsetDelta;
            this.anchorBottom = this.anchorBottom + verticalOffsetDelta;
            this.requestLayoutUpdate();
        };
        /**
         * initialize intersection detector
         */
        this.initializeIntersectionDetector = () => {
            this.disconnectIntersectionDetector();
            if (this.viewportElement === null) {
                this.viewportElement = this.getViewport();
            }
            if (this.viewportElement === null) {
                return;
            }
            if (this.useGbcr !== "never") {
                this.intersectionDetector = new IntersectionObserver(this.handleIntersection, {
                    root: this.viewportElement,
                    rootMargin: "0px",
                    threshold: [0, 1],
                });
            }
        };
        /**
         * starts observers
         */
        this.startObservers = () => {
            this.stopObservers();
            if (this.anchorElement === null ||
                this.viewportElement === null ||
                !this.viewportElement.contains(this.anchorElement)) {
                return;
            }
            this.startIntersectionObserver();
            if (this.resizeDetector !== null) {
                this.resizeDetector.observe(this.anchorElement);
                this.resizeDetector.observe(this);
                if (this.offsetParent !== null && this.offsetParent !== document.body) {
                    this.resizeDetector.observe(this.offsetParent);
                }
            }
        };
        /**
         * starts intersection observer
         */
        this.startIntersectionObserver = () => {
            if (this.anchorElement === null || this.viewportElement === null) {
                return;
            }
            if (this.intersectionDetector !== null) {
                this.intersectionDetector.observe(this);
                this.intersectionDetector.observe(this.anchorElement);
            }
        };
        /**
         * stops intersection observer
         */
        this.stopIntersectionObserver = () => {
            if (this.intersectionDetector !== null) {
                this.intersectionDetector.disconnect();
            }
        };
        /**
         * stops observers
         */
        this.stopObservers = () => {
            this.stopIntersectionObserver();
            if (this.resizeDetector !== null) {
                this.resizeDetector.disconnect();
            }
        };
        /**
         * handle window resizes
         */
        this.handleWindowResize = (ev) => {
            this.requestLayoutUpdate();
        };
        /**
         * disconnect intersection observer
         */
        this.disconnectIntersectionDetector = () => {
            if (this.intersectionDetector === null) {
                return;
            }
            this.intersectionDetector.disconnect();
            this.intersectionDetector = null;
        };
        /**
         * Gets the viewport element by id, or defaults to document root
         */
        this.getViewport = () => {
            if (typeof this.viewport !== "string" || this.viewport === "") {
                return document.body;
            }
            return document.getElementById(this.viewport);
        };
        /**
         *  Gets the anchor element by id
         */
        this.getAnchor = () => {
            return document.getElementById(this.anchor);
        };
        /**
         *  Confirms that there is a valid relationship between the viewport and the intersection entry
         *  ie. that the data is useful
         */
        this.isValidIntersection = (entry) => {
            return (entry.rootBounds !== null &&
                this.viewportElement !== null &&
                Math.round(entry.rootBounds.height) ===
                    Math.round(this.viewportElement.clientHeight));
        };
        /**
         *  Handle intersections
         */
        this.handleIntersection = (entries) => {
            if (this.viewportElement === null || this.anchorElement === null) {
                return;
            }
            let regionRect = null;
            if (!this.initialLayoutComplete) {
                if (entries.length !== 2) {
                    return;
                }
                if ((!this.isValidIntersection(entries[0]) ||
                    !this.isValidIntersection(entries[1])) &&
                    this.useGbcr !== "never") {
                    regionRect = this.applyNoIntersectionMode();
                }
                else {
                    regionRect = this.applyIntersectionEntries(entries);
                }
                if (regionRect !== null) {
                    this.updateRegionOffset(regionRect);
                }
                this.requestLayoutUpdate();
            }
            else {
                if (!this.noIntersectionMode) {
                    if (entries.length === 2) {
                        this.applyIntersectionEntries(entries);
                        this.requestLayoutUpdate();
                    }
                    else {
                        this.update();
                    }
                }
            }
        };
        /**
         *  use getBoundingClientRect when intersection observer fails
         */
        this.applyNoIntersectionMode = () => {
            this.noIntersectionMode = true;
            let regionRect = this.getBoundingClientRect();
            if (this.viewportElement === null ||
                this.anchorElement === null ||
                regionRect === null) {
                return null;
            }
            this.regionDimension = {
                height: regionRect.height,
                width: regionRect.width,
            };
            // todo: scomea, try to avoid getting viewportRect when it is document root
            this.viewportRect = this.viewportElement.getBoundingClientRect();
            const anchorRect = this.anchorElement.getBoundingClientRect();
            this.anchorTop = anchorRect.top;
            this.anchorRight = anchorRect.right;
            this.anchorBottom = anchorRect.bottom;
            this.anchorLeft = anchorRect.left;
            this.anchorHeight = anchorRect.height;
            this.anchorWidth = anchorRect.width;
            return regionRect;
        };
        /**
         *  iterate through intersection entries and apply data
         */
        this.applyIntersectionEntries = (entries) => {
            let regionRect = null;
            entries.forEach((entry) => {
                if (entry.target === this) {
                    this.handleRegionIntersection(entry);
                    regionRect = entry.boundingClientRect;
                }
                else {
                    this.handleAnchorIntersection(entry);
                }
            });
            return regionRect;
        };
        /**
         *  Update data based on anchor intersections
         */
        this.handleAnchorIntersection = (anchorEntry) => {
            this.viewportRect = anchorEntry.rootBounds;
            this.anchorTop = anchorEntry.boundingClientRect.top;
            this.anchorRight = anchorEntry.boundingClientRect.right;
            this.anchorBottom = anchorEntry.boundingClientRect.bottom;
            this.anchorLeft = anchorEntry.boundingClientRect.left;
            this.anchorHeight = anchorEntry.boundingClientRect.height;
            this.anchorWidth = anchorEntry.boundingClientRect.width;
        };
        /**
         *  Update data based on positioner intersections
         */
        this.handleRegionIntersection = (regionEntry) => {
            this.viewportRect = regionEntry.rootBounds;
            const regionRect = regionEntry.boundingClientRect;
            this.regionDimension = {
                height: regionRect.height,
                width: regionRect.width,
            };
        };
        /**
         *  Handle resize events
         */
        this.handleResize = (entries) => {
            entries.forEach((entry) => {
                if (entry.target === this) {
                    this.handleRegionResize(entry);
                }
                if (entry.target === this.anchorElement) {
                    if (entry.contentRect.height !== this.anchorHeight ||
                        entry.contentRect.width !== this.anchorWidth) {
                        this.update();
                    }
                }
                else {
                    // it is the viewport
                    if (this.offsetParent !== null &&
                        this.viewportRect !== null &&
                        (entry.contentRect.height !== this.viewportRect.height ||
                            entry.contentRect.width !== this.viewportRect.height)) {
                        this.update();
                    }
                }
            });
        };
        /**
         *  Handle region resize events
         */
        this.handleRegionResize = (entry) => {
            switch (this.horizontalScaling) {
                case "content":
                    this.regionDimension.width = entry.contentRect.width;
                    break;
                case "anchor":
                    this.regionDimension.width = this.anchorWidth;
                    break;
            }
            switch (this.verticalScaling) {
                case "content":
                    this.regionDimension.height = entry.contentRect.height;
                    break;
                case "anchor":
                    this.regionDimension.height = this.anchorHeight;
                    break;
            }
            this.requestLayoutUpdate();
        };
        /**
         * when there is not intersection observer this function is queued to update layout
         */
        this.updateGeometry = () => {
            let regionRect = this.applyNoIntersectionMode();
            if (regionRect !== null) {
                this.updateRegionOffset(regionRect);
            }
            this.requestLayoutUpdate();
        };
        /**
         * resets the component
         */
        this.reset = () => {
            if (!this.pendingReset) {
                return;
            }
            this.pendingReset = false;
            if (this.anchorElement === null) {
                this.anchorElement = this.getAnchor();
            }
            this.currentDirection = this.getDirection();
            this.startObservers();
            if (this.useGbcr === "always") {
                DOM.queueUpdate(this.updateGeometry);
            }
        };
        /**
         *  Recalculate layout related state values
         */
        this.updateLayout = () => {
            if (!this.pendingLayoutUpdate) {
                return;
            }
            this.pendingLayoutUpdate = false;
            if (this.viewportRect === null || this.regionDimension === null) {
                this.applyNoIntersectionMode();
            }
            let desiredVerticalPosition = AnchoredRegionVerticalPositionLabel.undefined;
            let desiredHorizontalPosition = AnchoredRegionHorizontalPositionLabel.undefined;
            if (this.horizontalPositioningMode !== "uncontrolled") {
                const horizontalOptions = this.getHorizontalPositioningOptions();
                if (this.horizontalDefaultPosition !== "unset") {
                    let dirCorrectedHorizontalDefaultPosition = this
                        .horizontalDefaultPosition;
                    if (dirCorrectedHorizontalDefaultPosition === "start" ||
                        dirCorrectedHorizontalDefaultPosition === "end") {
                        // if direction changes we reset the layout
                        const newDirection = this.getDirection();
                        if (newDirection !== this.currentDirection) {
                            this.currentDirection = newDirection;
                            this.initialize();
                            return;
                        }
                        if (this.currentDirection === Direction.ltr) {
                            dirCorrectedHorizontalDefaultPosition =
                                dirCorrectedHorizontalDefaultPosition === "start"
                                    ? "left"
                                    : "right";
                        }
                        else {
                            dirCorrectedHorizontalDefaultPosition =
                                dirCorrectedHorizontalDefaultPosition === "start"
                                    ? "right"
                                    : "left";
                        }
                    }
                    switch (dirCorrectedHorizontalDefaultPosition) {
                        case "left":
                            desiredHorizontalPosition = this.horizontalInset
                                ? AnchoredRegionHorizontalPositionLabel.insetLeft
                                : AnchoredRegionHorizontalPositionLabel.left;
                            break;
                        case "right":
                            desiredHorizontalPosition = this.horizontalInset
                                ? AnchoredRegionHorizontalPositionLabel.insetRight
                                : AnchoredRegionHorizontalPositionLabel.right;
                            break;
                    }
                }
                const horizontalThreshold = this.horizontalThreshold !== undefined
                    ? Number(this.horizontalThreshold)
                    : this.regionDimension.width;
                if (desiredHorizontalPosition ===
                    AnchoredRegionHorizontalPositionLabel.undefined ||
                    (!(this.horizontalPositioningMode === "locktodefault") &&
                        this.getAvailableWidth(desiredHorizontalPosition) <
                            horizontalThreshold)) {
                    desiredHorizontalPosition =
                        this.getAvailableWidth(horizontalOptions[0]) >
                            this.getAvailableWidth(horizontalOptions[1])
                            ? horizontalOptions[0]
                            : horizontalOptions[1];
                }
            }
            if (this.verticalPositioningMode !== "uncontrolled") {
                const verticalOptions = this.getVerticalPositioningOptions();
                if (this.verticalDefaultPosition !== "unset") {
                    switch (this.verticalDefaultPosition) {
                        case "top":
                            desiredVerticalPosition = this.verticalInset
                                ? AnchoredRegionVerticalPositionLabel.insetTop
                                : AnchoredRegionVerticalPositionLabel.top;
                            break;
                        case "bottom":
                            desiredVerticalPosition = this.verticalInset
                                ? AnchoredRegionVerticalPositionLabel.insetBottom
                                : AnchoredRegionVerticalPositionLabel.bottom;
                            break;
                    }
                }
                const verticalThreshold = this.verticalThreshold !== undefined
                    ? Number(this.verticalThreshold)
                    : this.regionDimension.height;
                if (desiredVerticalPosition ===
                    AnchoredRegionVerticalPositionLabel.undefined ||
                    (!(this.verticalPositioningMode === "locktodefault") &&
                        this.getAvailableHeight(desiredVerticalPosition) < verticalThreshold)) {
                    desiredVerticalPosition =
                        this.getAvailableHeight(verticalOptions[0]) >
                            this.getAvailableHeight(verticalOptions[1])
                            ? verticalOptions[0]
                            : verticalOptions[1];
                }
            }
            const nextPositionerDimension = this.getNextRegionDimension(desiredHorizontalPosition, desiredVerticalPosition);
            const positionChanged = this.horizontalPosition !== desiredHorizontalPosition ||
                this.verticalPosition !== desiredVerticalPosition;
            this.setHorizontalPosition(desiredHorizontalPosition, nextPositionerDimension);
            this.setVerticalPosition(desiredVerticalPosition, nextPositionerDimension);
            this.updateRegionStyle();
            this.initialLayoutComplete = true;
            if (positionChanged) {
                this.$emit("change");
            }
        };
        /**
         *  Updates the style string applied to the region element as well as the css classes attached
         *  to the root element
         */
        this.updateRegionStyle = () => {
            this.classList.toggle("top", this.verticalPosition === AnchoredRegionVerticalPositionLabel.top);
            this.classList.toggle("bottom", this.verticalPosition === AnchoredRegionVerticalPositionLabel.bottom);
            this.classList.toggle("inset-top", this.verticalPosition === AnchoredRegionVerticalPositionLabel.insetTop);
            this.classList.toggle("inset-bottom", this.verticalPosition === AnchoredRegionVerticalPositionLabel.insetBottom);
            this.classList.toggle("left", this.horizontalPosition === AnchoredRegionHorizontalPositionLabel.left);
            this.classList.toggle("right", this.horizontalPosition === AnchoredRegionHorizontalPositionLabel.right);
            this.classList.toggle("inset-left", this.horizontalPosition === AnchoredRegionHorizontalPositionLabel.insetLeft);
            this.classList.toggle("inset-right", this.horizontalPosition === AnchoredRegionHorizontalPositionLabel.insetRight);
            this.style.position = this.fixedPlacement ? "fixed" : "absolute";
            this.style.transformOrigin = `${this.yTransformOrigin} ${this.xTransformOrigin}`;
            this.style.opacity = this.initialLayoutComplete ? "1" : "0";
            if (this.horizontalPositioningMode === "uncontrolled") {
                this.style.width = "unset";
                this.style.right = "unset";
                this.style.left = "unset";
            }
            else {
                this.style.width = this.regionWidth;
                this.style.right = this.regionRight;
                this.style.left = this.regionLeft;
            }
            if (this.verticalPositioningMode === "uncontrolled") {
                this.style.height = "unset";
                this.style.top = "unset";
                this.style.bottom = "unset";
            }
            else {
                this.style.height = this.regionHeight;
                this.style.top = this.regionTop;
                this.style.bottom = this.regionBottom;
            }
        };
        /**
         * Get horizontal positioning state based on desired position
         */
        this.setHorizontalPosition = (desiredHorizontalPosition, nextPositionerDimension) => {
            const layoutParentWidth = this.offsetParent !== null
                ? this.offsetParent.clientWidth
                : document.body.clientWidth;
            let right = null;
            let left = null;
            let xTransformOrigin = Location.left;
            switch (desiredHorizontalPosition) {
                case AnchoredRegionHorizontalPositionLabel.left:
                    xTransformOrigin = Location.right;
                    right = layoutParentWidth - this.baseHorizontalOffset;
                    break;
                case AnchoredRegionHorizontalPositionLabel.insetLeft:
                    xTransformOrigin = Location.right;
                    right = layoutParentWidth - this.anchorWidth - this.baseHorizontalOffset;
                    break;
                case AnchoredRegionHorizontalPositionLabel.insetRight:
                    xTransformOrigin = Location.left;
                    left = this.baseHorizontalOffset;
                    break;
                case AnchoredRegionHorizontalPositionLabel.right:
                    xTransformOrigin = Location.left;
                    left = this.anchorWidth + this.baseHorizontalOffset;
                    break;
            }
            this.xTransformOrigin = xTransformOrigin;
            this.regionRight = right === null ? "unset" : `${right}px`;
            this.regionLeft = left === null ? "unset" : `${left}px`;
            this.horizontalPosition = desiredHorizontalPosition;
            switch (this.horizontalScaling) {
                case "anchor":
                    this.regionWidth = `${this.anchorWidth}px`;
                    break;
                case "fill":
                    this.regionWidth = `${nextPositionerDimension.width}px`;
                    break;
                case "content":
                    this.regionWidth = "fit-content";
                    break;
            }
        };
        /**
         * Get vertical positioning state based on desired position
         */
        this.setVerticalPosition = (desiredVerticalPosition, nextPositionerDimension) => {
            const layoutParentHeight = this.offsetParent !== null
                ? this.offsetParent.clientHeight
                : document.body.clientHeight;
            let top = null;
            let bottom = null;
            let yTransformOrigin = Location.top;
            switch (desiredVerticalPosition) {
                case AnchoredRegionVerticalPositionLabel.top:
                    yTransformOrigin = Location.bottom;
                    bottom = layoutParentHeight - this.baseVerticalOffset;
                    break;
                case AnchoredRegionVerticalPositionLabel.insetTop:
                    yTransformOrigin = Location.bottom;
                    bottom = layoutParentHeight - this.baseVerticalOffset - this.anchorHeight;
                    break;
                case AnchoredRegionVerticalPositionLabel.insetBottom:
                    yTransformOrigin = Location.top;
                    top = this.baseVerticalOffset;
                    break;
                case AnchoredRegionVerticalPositionLabel.bottom:
                    yTransformOrigin = Location.top;
                    top = this.baseVerticalOffset + this.anchorHeight;
                    break;
            }
            this.yTransformOrigin = yTransformOrigin;
            this.regionTop = top === null ? "unset" : `${top}px`;
            this.regionBottom = bottom === null ? "unset" : `${bottom}px`;
            this.verticalPosition = desiredVerticalPosition;
            switch (this.verticalScaling) {
                case "anchor":
                    this.regionHeight = `${this.anchorHeight}px`;
                    break;
                case "fill":
                    this.regionHeight = `${nextPositionerDimension.height}px`;
                    break;
                case "content":
                    this.regionHeight = "fit-content";
                    break;
            }
        };
        /**
         *  Update the offset values
         */
        this.updateRegionOffset = (regionRect) => {
            if (this.horizontalPositioningMode === "uncontrolled") {
                this.baseHorizontalOffset = this.anchorLeft - regionRect.left;
            }
            else {
                switch (this.horizontalPosition) {
                    case AnchoredRegionHorizontalPositionLabel.undefined:
                        this.baseHorizontalOffset = this.anchorLeft - regionRect.left;
                        break;
                    case AnchoredRegionHorizontalPositionLabel.left:
                        this.baseHorizontalOffset =
                            this.baseHorizontalOffset + (this.anchorLeft - regionRect.right);
                        break;
                    case AnchoredRegionHorizontalPositionLabel.insetLeft:
                        this.baseHorizontalOffset =
                            this.baseHorizontalOffset + (this.anchorRight - regionRect.right);
                        break;
                    case AnchoredRegionHorizontalPositionLabel.insetRight:
                        this.baseHorizontalOffset =
                            this.baseHorizontalOffset + (this.anchorLeft - regionRect.left);
                        break;
                    case AnchoredRegionHorizontalPositionLabel.right:
                        this.baseHorizontalOffset =
                            this.baseHorizontalOffset + (this.anchorRight - regionRect.left);
                        break;
                }
            }
            if (this.verticalPositioningMode === "uncontrolled") {
                this.baseVerticalOffset = this.anchorTop - regionRect.top;
            }
            else {
                switch (this.verticalPosition) {
                    case AnchoredRegionVerticalPositionLabel.undefined:
                        this.baseVerticalOffset = this.anchorTop - regionRect.top;
                        break;
                    case AnchoredRegionVerticalPositionLabel.top:
                        this.baseVerticalOffset =
                            this.baseVerticalOffset + (this.anchorTop - regionRect.bottom);
                        break;
                    case AnchoredRegionVerticalPositionLabel.insetTop:
                        this.baseVerticalOffset =
                            this.baseVerticalOffset + (this.anchorBottom - regionRect.bottom);
                        break;
                    case AnchoredRegionVerticalPositionLabel.insetBottom:
                        this.baseVerticalOffset =
                            this.baseVerticalOffset + (this.anchorTop - regionRect.top);
                        break;
                    case AnchoredRegionVerticalPositionLabel.bottom:
                        this.baseVerticalOffset =
                            this.baseVerticalOffset + (this.anchorBottom - regionRect.top);
                        break;
                }
            }
        };
        /**
         *  Get available Horizontal positions based on positioning mode
         */
        this.getHorizontalPositioningOptions = () => {
            if (this.horizontalInset) {
                return [
                    AnchoredRegionHorizontalPositionLabel.insetLeft,
                    AnchoredRegionHorizontalPositionLabel.insetRight,
                ];
            }
            return [
                AnchoredRegionHorizontalPositionLabel.left,
                AnchoredRegionHorizontalPositionLabel.right,
            ];
        };
        /**
         * Get available Vertical positions based on positioning mode
         */
        this.getVerticalPositioningOptions = () => {
            if (this.verticalInset) {
                return [
                    AnchoredRegionVerticalPositionLabel.insetTop,
                    AnchoredRegionVerticalPositionLabel.insetBottom,
                ];
            }
            return [
                AnchoredRegionVerticalPositionLabel.top,
                AnchoredRegionVerticalPositionLabel.bottom,
            ];
        };
        /**
         *  Get the width available for a particular horizontal position
         */
        this.getAvailableWidth = (positionOption) => {
            if (this.viewportRect !== null) {
                const spaceLeft = this.anchorLeft - this.viewportRect.left;
                const spaceRight = this.viewportRect.right - (this.anchorLeft + this.anchorWidth);
                switch (positionOption) {
                    case AnchoredRegionHorizontalPositionLabel.left:
                        return spaceLeft;
                    case AnchoredRegionHorizontalPositionLabel.insetLeft:
                        return spaceLeft + this.anchorWidth;
                    case AnchoredRegionHorizontalPositionLabel.insetRight:
                        return spaceRight + this.anchorWidth;
                    case AnchoredRegionHorizontalPositionLabel.right:
                        return spaceRight;
                }
            }
            return 0;
        };
        /**
         *  Get the height available for a particular vertical position
         */
        this.getAvailableHeight = (positionOption) => {
            if (this.viewportRect !== null) {
                const spaceAbove = this.anchorTop - this.viewportRect.top;
                const spaceBelow = this.viewportRect.bottom - (this.anchorTop + this.anchorHeight);
                switch (positionOption) {
                    case AnchoredRegionVerticalPositionLabel.top:
                        return spaceAbove;
                    case AnchoredRegionVerticalPositionLabel.insetTop:
                        return spaceAbove + this.anchorHeight;
                    case AnchoredRegionVerticalPositionLabel.insetBottom:
                        return spaceBelow + this.anchorHeight;
                    case AnchoredRegionVerticalPositionLabel.bottom:
                        return spaceBelow;
                }
            }
            return 0;
        };
        /**
         * Get region dimensions
         */
        this.getNextRegionDimension = (desiredHorizontalPosition, desiredVerticalPosition) => {
            const newRegionDimension = {
                height: this.regionDimension.height,
                width: this.regionDimension.width,
            };
            if (this.horizontalScaling === "fill") {
                newRegionDimension.width = this.getAvailableWidth(desiredHorizontalPosition);
            }
            if (this.verticalScaling === "fill") {
                newRegionDimension.height = this.getAvailableHeight(desiredVerticalPosition);
            }
            return newRegionDimension;
        };
        /**
         *  gets the current direction
         */
        this.getDirection = () => {
            const closest = this.closest(`[${AnchoredRegion.DirectionAttributeName}]`);
            return closest === null ||
                closest.getAttribute(AnchoredRegion.DirectionAttributeName) === Direction.ltr
                ? Direction.ltr
                : Direction.rtl;
        };
    }
    anchorChanged() {
        if (this.initialLayoutComplete) {
            this.anchorElement = this.getAnchor();
        }
    }
    viewportChanged() {
        if (this.initialLayoutComplete) {
            this.viewportElement = this.getViewport();
        }
    }
    horizontalPositioningModeChanged() {
        this.requestReset();
    }
    horizontalDefaultPositionChanged() {
        this.updateLayoutForAttributeChange();
    }
    horizontalInsetChanged() {
        this.updateLayoutForAttributeChange();
    }
    horizontalThresholdChanged() {
        this.updateLayoutForAttributeChange();
    }
    horizontalScalingChanged() {
        this.updateLayoutForAttributeChange();
    }
    verticalPositioningModeChanged() {
        this.requestReset();
    }
    verticalDefaultPositionChanged() {
        this.updateLayoutForAttributeChange();
    }
    verticalInsetChanged() {
        this.updateLayoutForAttributeChange();
    }
    verticalThresholdChanged() {
        this.updateLayoutForAttributeChange();
    }
    verticalScalingChanged() {
        this.updateLayoutForAttributeChange();
    }
    fixedPlacementChanged() {
        if (this.$fastController.isConnected &&
            this.initialLayoutComplete) {
            this.initialize();
        }
    }
    useGbcrChanged() {
        if (this.$fastController.isConnected &&
            this.initialLayoutComplete) {
            this.initialize();
        }
    }
    anchorElementChanged() {
        this.requestReset();
    }
    viewportElementChanged() {
        if (this.$fastController.isConnected &&
            this.initialLayoutComplete) {
            this.initialize();
        }
    }
    /**
     * @internal
     */
    connectedCallback() {
        super.connectedCallback();
        this.initialize();
    }
    /**
     * @internal
     */
    disconnectedCallback() {
        super.disconnectedCallback();
        this.disconnectResizeDetector();
        this.disconnectIntersectionDetector();
    }
    /**
     * @internal
     */
    adoptedCallback() {
        this.initialize();
    }
    /**
     * destroys the instance's resize observer
     */
    disconnectResizeDetector() {
        if (this.resizeDetector !== null) {
            this.resizeDetector.disconnect();
            this.resizeDetector = null;
        }
        window.removeEventListener("resize", this.handleWindowResize);
    }
    /**
     * initializes the instance's resize observer
     */
    initializeResizeDetector() {
        this.disconnectResizeDetector();
        this.resizeDetector = new window.ResizeObserver(this.handleResize);
        window.addEventListener("resize", this.handleWindowResize);
    }
    /**
     * event thrown when the region's position changes
     */
    updateLayoutForAttributeChange() {
        if (this.$fastController.isConnected &&
            this.initialLayoutComplete) {
            this.requestLayoutUpdate();
        }
    }
    /**
     * fully initializes the component
     */
    initialize() {
        this.initializeResizeDetector();
        this.initializeIntersectionDetector();
        this.setInitialState();
        if (this.anchorElement === null) {
            this.anchorElement = this.getAnchor();
        }
        this.requestReset();
    }
    /**
     * Request a layout update if there are currently no open requests
     */
    requestLayoutUpdate() {
        if (this.pendingLayoutUpdate === false && this.pendingReset === false) {
            this.pendingLayoutUpdate = true;
            DOM.queueUpdate(this.updateLayout);
        }
    }
    /**
     * Request a reset if there are currently no open requests
     */
    requestReset() {
        if (this.$fastController.isConnected &&
            this.pendingReset === false) {
            this.pendingLayoutUpdate = false;
            this.setInitialState();
            DOM.queueUpdate(this.reset);
            this.pendingReset = true;
        }
    }
    /**
     * sets the starting configuration for component internal values
     */
    setInitialState() {
        this.initialLayoutComplete = false;
        this.noIntersectionMode = false;
        this.regionTop = "0";
        this.regionRight = "unset";
        this.regionBottom = "unset";
        this.regionLeft = "0";
        this.regionWidth = "fit-content";
        this.regionHeight = "fit-content";
        this.xTransformOrigin = Location.left;
        this.yTransformOrigin = Location.top;
        this.viewportRect = null;
        this.regionDimension = { height: 0, width: 0 };
        this.anchorTop = 0;
        this.anchorRight = 0;
        this.anchorBottom = 0;
        this.anchorLeft = 0;
        this.anchorHeight = 0;
        this.anchorWidth = 0;
        this.verticalPosition = AnchoredRegionVerticalPositionLabel.undefined;
        this.horizontalPosition = AnchoredRegionHorizontalPositionLabel.undefined;
        this.baseHorizontalOffset = 0;
        this.baseVerticalOffset = 0;
        this.updateRegionStyle();
    }
}
AnchoredRegion.DirectionAttributeName = "dir";
__decorate([
    attr
], AnchoredRegion.prototype, "anchor", void 0);
__decorate([
    attr
], AnchoredRegion.prototype, "viewport", void 0);
__decorate([
    attr({ attribute: "horizontal-positioning-mode" })
], AnchoredRegion.prototype, "horizontalPositioningMode", void 0);
__decorate([
    attr({ attribute: "horizontal-default-position" })
], AnchoredRegion.prototype, "horizontalDefaultPosition", void 0);
__decorate([
    attr({ attribute: "horizontal-inset", mode: "boolean" })
], AnchoredRegion.prototype, "horizontalInset", void 0);
__decorate([
    attr({ attribute: "horizontal-threshold" })
], AnchoredRegion.prototype, "horizontalThreshold", void 0);
__decorate([
    attr({ attribute: "horizontal-scaling" })
], AnchoredRegion.prototype, "horizontalScaling", void 0);
__decorate([
    attr({ attribute: "vertical-positioning-mode" })
], AnchoredRegion.prototype, "verticalPositioningMode", void 0);
__decorate([
    attr({ attribute: "vertical-default-position" })
], AnchoredRegion.prototype, "verticalDefaultPosition", void 0);
__decorate([
    attr({ attribute: "vertical-inset", mode: "boolean" })
], AnchoredRegion.prototype, "verticalInset", void 0);
__decorate([
    attr({ attribute: "vertical-threshold" })
], AnchoredRegion.prototype, "verticalThreshold", void 0);
__decorate([
    attr({ attribute: "vertical-scaling" })
], AnchoredRegion.prototype, "verticalScaling", void 0);
__decorate([
    attr({ attribute: "fixed-placement", mode: "boolean" })
], AnchoredRegion.prototype, "fixedPlacement", void 0);
__decorate([
    attr({ attribute: "use-gbcr" })
], AnchoredRegion.prototype, "useGbcr", void 0);
__decorate([
    observable
], AnchoredRegion.prototype, "anchorElement", void 0);
__decorate([
    observable
], AnchoredRegion.prototype, "viewportElement", void 0);
__decorate([
    observable
], AnchoredRegion.prototype, "initialLayoutComplete", void 0);
