import { __decorate } from "tslib";
import { attr, DOM, FASTElement } from "@microsoft/fast-element";
import { keyCodeEscape, keyCodeTab } from "@microsoft/fast-web-utilities";
import tabbable from "tabbable";
/**
 * A Switch Custom HTML Element.
 * Implements the {@link https://www.w3.org/TR/wai-aria-1.1/#dialog | ARIA dialog }.
 *
 * @public
 */
export class Dialog extends FASTElement {
    constructor() {
        super(...arguments);
        /**
         * Indicates the element is modal. When modal, user interaction will be limited to the contents of the element.
         * @public
         * @defaultValue - true
         * @remarks
         * HTML Attribute: modal
         */
        this.modal = true;
        /**
         * The hidden state of the element.
         *
         * @public
         * @defaultValue - false
         * @remarks
         * HTML Attribute: hidden
         */
        this.hidden = false;
        /**
         * Indicates that the dialog should trap focus.
         *
         * @public
         * @defaultValue - true
         * @remarks
         * HTML Attribute: trap-focus
         */
        this.trapFocus = true;
        this.trapFocusChanged = () => {
            if (this.shouldDialogTrapFocus()) {
                // Add an event listener for focusin events if we should be trapping focus
                document.addEventListener("focusin", this.handleDocumentFocus);
                // determine if we should move focus inside the dialog
                if (this.shouldForceFocus(document.activeElement)) {
                    this.focusFirstElement();
                }
            }
            else {
                // remove event listener if we are not trapping focus
                document.removeEventListener("focusin", this.handleDocumentFocus);
            }
        };
        this.handleDocumentKeydown = (e) => {
            if (!e.defaultPrevented && !this.isDialogHidden()) {
                switch (e.keyCode) {
                    case keyCodeEscape:
                        this.dismiss();
                        break;
                    case keyCodeTab:
                        this.handleTabKeyDown(e);
                        break;
                }
            }
        };
        this.handleDocumentFocus = (e) => {
            if (!e.defaultPrevented && this.shouldForceFocus(e.target)) {
                this.focusFirstElement();
                e.preventDefault();
            }
        };
        this.handleTabKeyDown = (e) => {
            if (!this.shouldDialogTrapFocus()) {
                return;
            }
            const tabbableElementCount = this.tabbableElements.length;
            if (tabbableElementCount === 0) {
                this.dialog.focus();
                e.preventDefault();
                return;
            }
            if (e.shiftKey && e.target === this.tabbableElements[0]) {
                this.tabbableElements[tabbableElementCount - 1].focus();
                e.preventDefault();
            }
            else if (!e.shiftKey &&
                e.target === this.tabbableElements[tabbableElementCount - 1]) {
                this.tabbableElements[0].focus();
                e.preventDefault();
            }
        };
        /**
         * focus on first element of tab queue
         */
        this.focusFirstElement = () => {
            if (this.tabbableElements.length === 0) {
                this.dialog.focus();
            }
            else {
                this.tabbableElements[0].focus();
            }
        };
        /**
         * we should only focus if focus has not already been brought to the dialog
         */
        this.shouldForceFocus = (currentFocusElement) => {
            return !this.isDialogHidden() && !this.contains(currentFocusElement);
        };
    }
    /**
     * @internal
     */
    dismiss() {
        this.$emit("dismiss");
    }
    /**
     * @internal
     */
    connectedCallback() {
        super.connectedCallback();
        // store references to tabbable elements
        this.tabbableElements = tabbable(this);
        this.observer = new MutationObserver(this.onChildListChange);
        // only observe if nodes are added or removed
        this.observer.observe(this, { childList: true });
        document.addEventListener("keydown", this.handleDocumentKeydown);
        // Ensure the DOM is updated
        // This helps avoid a delay with `autofocus` elements recieving focus
        DOM.queueUpdate(this.trapFocusChanged);
    }
    /**
     * @internal
     */
    disconnectedCallback() {
        super.disconnectedCallback();
        // disconnect observer
        this.observer.disconnect();
        // remove keydown event listener
        document.removeEventListener("keydown", this.handleDocumentKeydown);
        // if we are trapping focus remove the focusin listener
        if (this.shouldDialogTrapFocus()) {
            document.removeEventListener("focusin", this.handleDocumentFocus);
        }
    }
    onChildListChange(mutations, 
    /* eslint-disable-next-line @typescript-eslint/no-unused-vars */
    observer) {
        if (mutations.length) {
            this.tabbableElements = tabbable(this);
        }
    }
    /**
     * TODO: Issue #2742 - https://github.com/microsoft/fast/issues/2742
     * This is a placeholder function to check if the hidden attribute is present
     * Currently there is not support for boolean attributes.
     * Once support is added, we will simply use this.hidden.
     */
    isDialogHidden() {
        return typeof this.hidden !== "boolean";
    }
    /**
     * TODO: Issue #2742 - https://github.com/microsoft/fast/issues/2742
     * This is a placeholder function to check if the trapFocus attribute is present
     * Currently there is not support for boolean attributes.
     * Once support is added, we will simply use this.trapFocus.
     */
    shouldDialogTrapFocus() {
        return typeof this.trapFocus === "boolean";
    }
}
__decorate([
    attr({ mode: "boolean" })
], Dialog.prototype, "modal", void 0);
__decorate([
    attr({ mode: "boolean" })
], Dialog.prototype, "hidden", void 0);
__decorate([
    attr({ attribute: "trap-focus", mode: "boolean" })
], Dialog.prototype, "trapFocus", void 0);
__decorate([
    attr({ attribute: "aria-describedby" })
], Dialog.prototype, "ariaDescribedby", void 0);
__decorate([
    attr({ attribute: "aria-labelledby" })
], Dialog.prototype, "ariaLabelledby", void 0);
__decorate([
    attr({ attribute: "aria-label" })
], Dialog.prototype, "ariaLabel", void 0);
