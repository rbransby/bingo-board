import { __decorate } from "tslib";
import { attr, observable } from "@microsoft/fast-element";
import { keyCodeSpace } from "@microsoft/fast-web-utilities";
import { FormAssociated } from "../form-associated/form-associated";
/**
 * An Switch Custom HTML Element.
 * Implements the {@link https://www.w3.org/TR/wai-aria-1.1/#switch | ARIA switch }.
 *
 * @public
 */
export class Radio extends FormAssociated {
    constructor() {
        super(...arguments);
        /**
         * The element's value to be included in form submission when checked.
         * Default to "on" to reach parity with input[type="radio"]
         *
         * @internal
         */
        this.initialValue = "on"; // Map to proxy element.
        /**
         * Initialized to the value of the checked attribute. Can be changed independently of the "checked" attribute,
         * but changing the "checked" attribute always additionally sets this value.
         *
         * @public
         */
        this.defaultChecked = !!this.checkedAttribute;
        /**
         * The checked state of the control
         *
         * @public
         */
        this.checked = this.defaultChecked;
        this.proxy = document.createElement("input");
        /**
         * Tracks whether the "checked" property has been changed.
         * This is necessary to provide consistent behavior with
         * normal input radios
         */
        this.dirtyChecked = false;
        /**
         * @internal
         */
        this.keypressHandler = (e) => {
            super.keypressHandler(e);
            switch (e.keyCode) {
                case keyCodeSpace:
                    if (!this.checked && !this.readOnly) {
                        this.checked = true;
                    }
                    break;
            }
        };
        /**
         * @internal
         */
        this.clickHandler = (e) => {
            if (!this.disabled && !this.readOnly) {
                this.checked = !this.checked;
            }
        };
    }
    readOnlyChanged() {
        if (this.proxy instanceof HTMLElement) {
            this.proxy.readOnly = this.readOnly;
        }
    }
    nameChanged() {
        if (this.proxy instanceof HTMLElement) {
            this.proxy.name = this.name;
        }
    }
    checkedAttributeChanged() {
        this.defaultChecked = this.checkedAttribute;
    }
    defaultCheckedChanged() {
        if (!this.dirtyChecked) {
            // Setting this.checked will cause us to enter a dirty state,
            // but if we are clean when defaultChecked is changed, we want to stay
            // in a clean state, so reset this.dirtyChecked
            this.checked = this.defaultChecked;
            this.dirtyChecked = false;
        }
    }
    checkedChanged() {
        if (!this.dirtyChecked) {
            this.dirtyChecked = true;
        }
        if (this.proxy instanceof HTMLElement) {
            this.proxy.checked = this.checked;
        }
        this.$emit("change");
        this.checkedAttribute = this.checked;
        this.updateForm();
    }
    /**
     * @internal
     */
    connectedCallback() {
        var _a;
        super.connectedCallback();
        this.proxy.setAttribute("type", "radio");
        if (((_a = this.parentElement) === null || _a === void 0 ? void 0 : _a.getAttribute("role")) !== "radiogroup" &&
            this.getAttribute("tabindex") === null) {
            if (!this.disabled) {
                this.setAttribute("tabindex", "0");
            }
        }
        this.updateForm();
    }
    updateForm() {
        const value = this.checked ? this.value : null;
        this.setFormValue(value, value);
    }
}
__decorate([
    attr({ attribute: "readonly", mode: "boolean" })
], Radio.prototype, "readOnly", void 0);
__decorate([
    attr
], Radio.prototype, "name", void 0);
__decorate([
    attr({ attribute: "checked", mode: "boolean" })
], Radio.prototype, "checkedAttribute", void 0);
__decorate([
    observable
], Radio.prototype, "defaultSlottedNodes", void 0);
__decorate([
    observable
], Radio.prototype, "defaultChecked", void 0);
__decorate([
    observable
], Radio.prototype, "checked", void 0);
