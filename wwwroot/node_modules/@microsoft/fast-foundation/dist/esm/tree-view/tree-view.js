import { __decorate } from "tslib";
import { attr, DOM, FASTElement, observable } from "@microsoft/fast-element";
import { isHTMLElement, keyCodeEnd, keyCodeHome } from "@microsoft/fast-web-utilities";
import { isTreeItemElement } from "../tree-item";
/**
 * A Tree view Custom HTML Element.
 * Implements the {@link https://w3c.github.io/aria-practices/#TreeView | ARIA TreeView }.
 *
 * @public
 */
export class TreeView extends FASTElement {
    constructor() {
        super(...arguments);
        this.focusable = true;
        this.handleBlur = (e) => {
            const root = this.treeView;
            /**
             * If we focus outside of the tree
             */
            if (isHTMLElement(root) && !root.contains(e.relatedTarget)) {
                this.focusable = true;
            }
            this.ensureFocusability();
        };
        this.handleFocus = (e) => {
            if (!isHTMLElement(this.treeView)) {
                return;
            }
            const root = this.treeView;
            const lastFocused = this.lastFocused;
            /**
             * If the tree view is receiving focus
             */
            if (isHTMLElement(root) && root === e.target) {
                // If we have a last focused item, focus it - otherwise check for an initially selected item or focus the first "[role='treeitem']"
                // If there is no "[role='treeitem']" to be focused AND no last-focused, then there are likely no children
                // or children are malformed so keep the tree in the tab-order in the hopes that the author cleans up
                // the children
                const selectedChild = root.querySelector("[aria-selected='true']");
                const toBeFocused = !!lastFocused
                    ? lastFocused
                    : !!selectedChild
                        ? selectedChild
                        : root.querySelector("[role='treeitem']");
                if (toBeFocused && isHTMLElement(toBeFocused)) {
                    toBeFocused.focus();
                    if (this.focusable) {
                        this.focusable = false;
                    }
                }
            }
            else {
                // A child is receiving focus. While focus is within the tree, we simply need to ensure
                // that the tree is not focusable.
                if (this.focusable) {
                    this.focusable = false;
                }
            }
        };
        this.handleKeyDown = (e) => {
            if (!this.treeItems) {
                return true;
            }
            switch (e.keyCode) {
                case keyCodeHome:
                    if (this.treeItems && this.treeItems.length) {
                        this.treeItems[0].focus();
                    }
                    break;
                case keyCodeEnd:
                    if (this.treeItems && this.treeItems.length) {
                        this.treeItems[this.treeItems.length - 1].focus();
                    }
                    break;
                default:
                    return true;
            }
        };
        this.setItems = () => {
            const focusIndex = this.treeItems.findIndex(this.isFocusableElement);
            for (let item = 0; item < this.treeItems.length; item++) {
                if (item === focusIndex && !this.treeItems[item].hasAttribute("disabled")) {
                    this.treeItems[item].setAttribute("tabindex", "0");
                }
                this.treeItems[item].addEventListener("selected-change", this.handleItemSelected);
            }
        };
        this.resetItems = () => {
            for (let item = 0; item < this.treeItems.length; item++) {
                this.treeItems[item].removeEventListener("selected-change", this.handleItemSelected);
            }
        };
        this.handleItemSelected = (e) => {
            const newSelection = e.target;
            if (newSelection !== this.currentSelected) {
                if (this.currentSelected) {
                    // TODO: fix this below, shouldn't need both
                    this.currentSelected.removeAttribute("selected");
                    this.currentSelected.selected = false;
                }
                this.currentSelected = newSelection;
            }
        };
        /**
         * check if the item is focusable
         */
        this.isFocusableElement = (el) => {
            return isTreeItemElement(el) && !this.isDisabledElement(el);
        };
        /**
         * check if the item is disabled
         */
        this.isDisabledElement = (el) => {
            return isTreeItemElement(el) && el.getAttribute("aria-disabled") === "true";
        };
    }
    slottedTreeItemsChanged(oldValue, newValue) {
        if (this.$fastController.isConnected) {
            // filter the tree items until that's done for us in the framework
            this.resetItems();
            this.treeItems = this.getVisibleNodes();
            this.setItems();
            // check if any tree items have nested items
            // if they do, apply the nested attribute
            if (this.checkForNestedItems()) {
                this.slottedTreeItems.forEach(node => {
                    if (isTreeItemElement(node)) {
                        node.nested = true;
                    }
                });
            }
        }
    }
    checkForNestedItems() {
        return this.slottedTreeItems.some((node) => {
            return isTreeItemElement(node) && node.querySelector("[role='treeitem']");
        });
    }
    connectedCallback() {
        super.connectedCallback();
        this.treeItems = this.getVisibleNodes();
        DOM.queueUpdate(() => {
            //only supporting single select
            const node = this.treeView.querySelector("[aria-selected='true']");
            if (node) {
                this.currentSelected = node;
            }
        });
        this.ensureFocusability();
    }
    getVisibleNodes() {
        const treeItems = [];
        if (this.slottedTreeItems !== undefined) {
            this.slottedTreeItems.forEach((item) => {
                if (isTreeItemElement(item)) {
                    treeItems.push(item);
                }
            });
        }
        return treeItems;
    }
    /**
     * Verifies that the tree has a focusable child.
     * If it does not, the tree will begin to accept focus
     */
    ensureFocusability() {
        if (!this.focusable && isHTMLElement(this.treeView)) {
            const focusableChild = this.querySelector("[role='treeitem'][tabindex='0']");
            if (!isHTMLElement(focusableChild)) {
                this.focusable = true;
            }
        }
    }
}
__decorate([
    attr({ attribute: "render-collapsed-nodes" })
], TreeView.prototype, "renderCollapsedNodes", void 0);
__decorate([
    observable
], TreeView.prototype, "focusable", void 0);
__decorate([
    observable
], TreeView.prototype, "currentSelected", void 0);
__decorate([
    observable
], TreeView.prototype, "lastFocused", void 0);
__decorate([
    observable
], TreeView.prototype, "nested", void 0);
__decorate([
    observable
], TreeView.prototype, "slottedTreeItems", void 0);
